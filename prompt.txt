角色设定： 你是一位精通 Python 的后端架构师，擅长使用 FastAPI 和 Google OR-Tools 解决复杂的调度与排班问题。
项目背景： 我们需要开发一个排班系统的后端，为一个 17 人的班组生成“做一休二”的轮班表。 核心挑战在于：每天的岗位（Slot）数量固定为 17 个，人员也固定为 17 人。难点在于如何根据人员的身份属性（是否为夜班长）和避让规则，将这 17 个人合理地分配到这 17 个坑位中，并保证月度公平性（大夜班次数均衡）。
1. 技术栈要求
语言框架： Python 3.10+, FastAPI (用于提供 RESTful API)。
核心算法库： ortools.sat.python.cp_model (用于约束求解) 或 random + heuristics (启发式算法)。
数据处理： Pandas (用于处理 Excel 导出)。
数据存储： 暂时使用 SQLite 或内存 JSON 模拟（需设计好 Pydantic Model）。
2. 核心业务逻辑 (Memory Context)
A. 时间与轮班周期 (The Anchor Logic)
机制： 三班倒，做一休二（Cycle = 3天）。
计算逻辑： 不要在数据库存储每一天。请实现一个算法：
设定锚点：2024-01-01 为 A组 工作日。
输入查询月份（如 2024-10），自动计算出该月 A 组的所有工作日列表。
B. 每日岗位定员 (Hard Constraints)
每个工作日必须填满以下 17 个席位（总数不可变）：
白班 (6人)： 普通席位。
睡觉班 (5人)： 1个主任席 + 2个西北席 + 2个东南席。
小夜班 (3人)： 1个主任席 + 2个普通席。
大夜班 (3人)： 1个主任席 + 2个普通席。
C. 人员属性与限制
总人数： 17人。
夜班长 (Key Role)： 人员列表中的前 6 人 (Index 0-5)。
规则： 睡觉班、小夜班、大夜班的 “主任席” 必须且只能由这 6 人担任。
避让组 (Avoidance)： 系统维护一个“互斥列表”（如 [[UserA, UserB], [UserC, UserD]]）。
规则： 尽量避免同一组的人分配到同一个班次类型（例如不要两人都是大夜）。如果无法避免，给予算法惩罚权重。
3. 核心 API 接口定义
请实现以下 endpoint：
1. POST /api/schedule/generate (自动排班核心)
输入：
month: "2024-10"
group_id: "A" (用于计算工作日)
employees: 员工列表（含 ID、姓名、是否夜班长）。
constraints: 避让组配置。
逻辑（算法步骤）：
根据锚点算出该月所有工作日。
对每个工作日进行分配：
Step 1: 先将 3 个夜班主任席和 1 个睡觉班主任席（共4席），分配给 6 名夜班长中的 4 人。
Step 2: 将剩余的 2 名夜班长和 11 名普通员工（共13人），填入剩余的 13 个普通席位（白班+各班次普通席）。
Step 3 (公平性优化): 在整月范围内，确保每人的“大夜班”总数标准差最小（即大家的大夜班次数尽量平均）。
输出： 符合前端渲染结构的 JSON（包含每一天、每个人的班次和席位）。
2. POST /api/schedule/validate (实时校验)
输入： 单日的排班数据。
功能： 检查是否满足“定员17人”、“主任席资格正确”、“避让组冲突”。
输出： isValid (bool) 和 errors (数组，包含具体的冲突描述)。
3. POST /api/schedule/export (导出)
输入： 前端最终调整好的排班 JSON。
功能： 使用 Pandas/OpenPyXL 生成带有格式（合并单元格、颜色标记）的 .xlsx 文件。
返回： 文件流 (FileResponse)。
4. 代码实现建议
请优先创建一个 SchedulingSolver 类。
使用 cp_model.CpModel() 建立模型。
创建布尔变量 x[employee, day, shift_type]。
添加约束：sum(x[e, d, shift]) == 1 (每人每天一班)，sum(x[..., shift]) == limit (定员限制)。
目标函数：Minimize(大夜班方差 + 避让冲突惩罚)。